FORMAT: 1A

# Solar Decathlon Automation
This API governs the interaction between the solar decathlon wireless client 
tablets and the central home automation server.

## Devices

Devices are named by IDs, which are strings. These strings are essentially
hard-coded; it's easier that way. There are two kinds of IDs: "sensor IDs"
and "control IDs". I think it will be easier just to have a convention
to distinguish them. This is going to reek of 1990's Microsoft hungarian
notation, but who
cares.

### Completely tentative list of IDs:

- `s-temp-lr` : the temperature in the living room
- `s-occ-lr` : whether the living room is occupied
- `s-amb-lr` : the ambient light level in the living room
- `c-light-lr` : control of the lights in the living room
- `s-light-lr` : a record of the lighting control events in the living room
- `s-temp-bath` : the temperature in the bathroom
- `s-occ-bath` : whether the bathroom is occupied
- `s-amb-bath` : the ambient light level in the bathroom
- `c-light-bath` : control of the lights in the bathroom
- `s-light-bath` : a record of the lighting control events in the bathroom
- `s-temp-kit` : the temperature in the kitchen
- `s-occ-kit` : whether the kitchen is occupied
- `s-amb-kit` : the ambient light level in the kitchen
- `c-light-kit` : control of the lights in the kitchen
- `s-light-kit` : a record of the lighting control events in the kitchen
- `s-temp-bed` : the temperature in the bedroom
- `s-occ-bed` : whether the bedroom is occupied
- `s-amb-bed` : the ambient light level in the bedroom
- `c-light-bed` : control of the lights in the bedroom
- `s-light-bed` : a record of the lighting control events in the bedroom

## Clients

I'm expecting to have to use a 'push' model to communicate to the clients.
Clients will register themselves, and then the server will send them HTTP
messages whenever an event occurs. We could allow clients to register 
for messages on just a subset of devices, but I think that'll just be one
more thing to break. It's going to be multiple messages per second, but
I think that should be okay.

Clients will register using their IP addresses, and they'll receive a 
token that they can use to unregister. Honestly, though, you have to
assume that clients will often be badly-behaved, and will simply
drop off the edge of the earth; the server will have to handle
these gracefully and without undue lag.

## Implementation

Currently, the toy server implements only the resources listed as 
[IMPLEMENTED]. It also does some temperature stuff, but it doesn't
yet match the API, so....

# Group Server

This API describes calls that the clients make to the server.

# Ping [/srv/ping]

Checks that the server is alive. [IMPLEMENTED]

## Check Server Life [GET]

+ Response 200 (application/json)

    + Body

            "alive"


# Timestamp [/srv/timestamp]

The current timestamp from the server (represented as seconds since epoch on 
server). [IMPLEMENTED]

## Get Current Timestamp [GET]

+ Response 200 (application/json)

    + Body

            {
                "timestamp":1418096756
            }


# Timestamp From Date [/srv/timestamp/from-date]

*[NOTE: I've waffled quite a bit over what API to provide here; we want
the server to be in charge of time, but we don't want the clients
to be hammering the server to see what every timestamp means.
I think the right compromise is to provide a call that allows
the clients to "get their bearings" by converting a date to a
timestamp, but not vice versa.]*

Here's the shape of the "post" data, as json:

*[I bet there's some way to put the response in formally....]*

```json
{"day": <number>,
 "month": <number>,
 "year": <number>}
```

## Compute the timestamp for a date [POST]

+ Response 200 (application/json)

    + Body

            {
                "timestamp":1418096756
            }


# Device Latest Event [/srv/device/{id}/latest-event]

The last event of the given device. [IMPLEMENTED]

+ Parameters
    + id (string) ... the ID of the device

## Latest Event [GET]

+ Response 200 (application/json)

    + Body

            {
                "reading":"7989",
                "timestamp":1418096755
            }


# Device Event Range [/srv/device/{id}/event-range?start={start},end={end}]

Fetch all events in the given range. More specifically, those with
timestamps `n` such that `start <= n < end`.

+ Parameters
    + start (integer) ... the timestamp of the beginning of the range
    + end (integer) ... the timestamp of the end of the range

## Get events in a range [GET]

+ Response 200 (application/json)

    + Body

            [{"reading":"77982","timestamp":1418096755},
             {"reading":"77983","timestamp":1418096758},
             {"reading":"77982","timestamp":1418096761},
             {"reading":"77980","timestamp":1418096764}]


# Register a Client [/srv/register-client?ip={ip}]

Register a client to receive all events from all sensor
device streams.

+ Parameters
    + ip (string) ... the IPV4 address of the client device

## Register a Client [PUT]

+ Response 200 (application/json)
    + Body
    
            {
                "unreg-token":"AA3MPHT234"
            }


# Unregister a client [/srv/unregister-client?token={token}]

Remove the client with the given token from the list of registered
clients.

# Group Client

The API for messages sent to the Client

# Event Notification [/cli/{id}/event]

An event has occurred for this device.

How do I document the shape of the POST data? Hmm...

+ Parameters
    + id (string) ... the id of the device with the new event
    
## Event has occurred [POST]

+ Response 200 (application/json)
    + Body
    
            "ok"


