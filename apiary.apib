FORMAT: 1A
HOST: http://calpolysolardecathlon.org:8080

# Solar Decathlon Automation
This API governs the interaction between the solar decathlon wireless client 
tablets and the central home automation server.

## Devices

Devices are named by IDs, which are strings. These strings are essentially
hard-coded; it's easier that way. There are two kinds of IDs: "sensor IDs"
and "control IDs". I think it will be easier just to have a convention
to distinguish them. This is going to reek of 1990's Microsoft hungarian
notation, but who cares.

### Completely tentative list of IDs:

- `s-temp-lr` : the temperature in the living room
- `s-occ-lr` : whether the living room is occupied
- `s-amb-lr` : the ambient light level in the living room
- `c-light-lr` : control of the lights in the living room
- `s-light-lr` : a record of the lighting control events in the living room
- `s-temp-bath` : the temperature in the bathroom
- `s-occ-bath` : whether the bathroom is occupied
- `s-amb-bath` : the ambient light level in the bathroom
- `c-light-bath` : control of the lights in the bathroom
- `s-light-bath` : a record of the lighting control events in the bathroom
- `s-temp-kit` : the temperature in the kitchen
- `s-occ-kit` : whether the kitchen is occupied
- `s-amb-kit` : the ambient light level in the kitchen
- `c-light-kit` : control of the lights in the kitchen
- `s-light-kit` : a record of the lighting control events in the kitchen
- `s-temp-bed` : the temperature in the bedroom
- `s-occ-bed` : whether the bedroom is occupied
- `s-amb-bed` : the ambient light level in the bedroom
- `c-light-bed` : control of the lights in the bedroom
- `s-light-bed` : a record of the lighting control events in the bedroom
- ... others....

## Clients

In this revision, I'm thinking about publish-subscribe. Looks easier
to implement and test than websockets.

## Implementation

Currently, the test server implements only the resources listed as 
[IMPLEMENTED]. 

# Group Server

This API describes calls that the clients make to the server.

# Ping [/srv/ping]

Checks that the server is alive. [IMPLEMENTED]

## Ping [GET]

+ Response 200 (application/json)

    + Body

            "alive"


# Timestamp [/srv/timestamp]

The current timestamp from the server (represented as seconds since epoch on 
server). [IMPLEMENTED]

## Timestamp [GET]

+ Response 200 (application/json)

    + Body

            {
                "timestamp":1418096756
            }


# Timestamp From Date [/srv/timestamp/from-date]

*[NOTE: I've waffled quite a bit over what API to provide here; we want
the server to be in charge of time, but we don't want the clients
to be hammering the server to see what every timestamp means.
I think the right compromise is to provide a call that allows
the clients to "get their bearings" by converting a midnight-UTC date to a
timestamp, but not vice versa.]*

## Compute the timestamp for a UTC midnight date [POST]

+ Request (application/json)

    + Body

            {   "day" : 12,
                "month" : 2,
                "year" : 2015 }

+ Response 200 (application/json)

    + Body

            {
                "timestamp":1418096756
            }


# Device Latest Event [/srv/device/{id}/latest-event]

The last event of the given device. [IMPLEMENTED]

+ Parameters
    + id (string) ... the ID of the device

## Latest Event [GET]

+ Response 200 (application/json)

    + Body

            {
                "device-id":"{id}"
                "status":"{status}",
                "timestamp":{timestamp}
            }


# Device Event Range [/srv/device/{id}/event-range?start={start},end={end}]

Fetch all events in the given range. More specifically, those with
timestamps `n` such that `start <= n < end`.

+ Parameters
    + start (integer) ... the timestamp of the beginning of the range
    + end (integer) ... the timestamp of the end of the range

## Get events in a range [GET]

+ Response 200 (application/json)

    + Body

            [{"device":"foo", "status":"77982","timestamp":1418096755},
             {"device":"foo", "status":"77983","timestamp":1418096758},
             {"device":"foo", "status":"77982","timestamp":1418096761},
             {"device":"foo", "status":"77980","timestamp":1418096764}]


# Subscribe to Events [/srv/subscribe]

Register a client with the server, to receive all events as they occur.
NB: There's no unsubscribe; I don't think it'll ever be necessary, and
the server will have to handle disappearing subscribers anyway.

## Subscribe [POST]

Some authentication here might be nice.  I'm going to leave it
out for now.

+ Request (application/json)

    + Body

            {"ip":"xxx.xxx.xxx.xxx"}

+ Response 200 (application/json)

    + Body

            true


# Group Client

# Notify [/totally/bogus]

Notification that an event has occurred.

As an aside, this model (that is, apiary) is totally broken... I can't refer to a model
from outside? There are some major issues here.

## Event [/client/notify]

Messages sent from the server to a subscribed client

+ Model (application/json)

    A JSON object representing a control or sensor event

    As a side note... this JSON schema mechanism is... weak.

    + Body

            {   "type": "controlorsensor",
                "device" : "thedevicename",
                "timestamp" : 472379717,
                "reading" : 2271938470
            }


### Notify [POST]

+ Request (application/json)
    [Event][]

+ Response 200 (application/json)

    + Body

            true

