FORMAT: 1A
HOST: http://calpolysolardecathlon.org:8080

# Solar Decathlon Automation
This API governs the interaction between the solar decathlon wireless client 
tablets and the central home automation server.

## Devices

REWRITE FOR INFLUXDB STARTS HERE...

## Measurements

All recorded measurements must fall into one of these measurement categories:

- `temperature`
- `humidity`
- `electric_power`
- `light_level`
- `occupied`

## Devices

Device names specify locations. Each measurement has its own set of legal
device names.

### Temperature and Humidity Devices

- `living_room`
- `bedroom`
- `kitchen`
- `outside`
- `bathroom`
- `testing_blackhole`

### Electric Power devices

In order to maintain flexibility, we're just going to go with the flow,
and accept whatever device ids come in from the eGauge. Note that no
distinction is made here between power generated and power used.


## Representing Sensor Readings

Sensor readings are encoded as signed 64-bit integers.

For temperatures, these
are 10ths of celsius degrees. So, for instance, the temperature -3.4 degrees
celsius would be represented as -34.

Humidities are reported in 10ths of
a percent of relative humidity. So, for instance, 78.4% humidity would
be represented as 784.

Light settings are specified as tenths of a percent
(like humidity). So, for instance, a light that's on would be represented
as 1000, and one set at 20% would be represented as 200.

Electrical power readings are specified in CUMULATIVE watt-seconds.
PLEASE NOTE: under some circumstances, this counter may get reset. Display
modules should be cognizant of this, and do the best they can if this
value is seen to drop.

## Implementation

Currently, the test server does not implement the resources listed as
[UNIMPLEMENTED].

# Group Server

This API describes calls that the clients make to the server.

# Ping [/srv/ping]

Checks that the server is alive.

## Ping [GET]

+ Response 200 (application/json)

    + Body

            "alive"


# Timestamp [/srv/timestamp]

The current timestamp from the server (represented as seconds since epoch
UTC on server).

## Timestamp [GET]

+ Response 200 (application/json)

    + Body

            {
                "timestamp":1418096756
            }


# Device Latest Event [/srv/latest-event{?measurement,device}]

The last event of the given device.

+ Parameters
    + measurement (string) ... the kind of measurement (temperature, etc.)
    + device (string) ... the id of the selected device


## Latest Event [GET]

+ Response 200 (application/json)

    + Body
            {status}

# Post a sensor reading [/srv/record-reading{?device}]

## Record Reading [POST]

A Post request adds new data, using the server's current
timestamp. There's a (plaintext) secret used to validate
the sender. Since this request just travels over the local
wire, we don't need to worry about encrypting it. Famous
last words.

+ Request (application/json)

            {
                "status":{status},
                "secret":{secret}
            }

+ Response 200 (application/json)

    + Body

            "okay"


# Device Subsampling by Mean [/srv/mean-by-interval{?measurement,device,start,end,interval}]

Aggregate the data by returning the mean reading for each interval in the given range.
Ranges that don't have any data will return the reading 'false'.

NB: this will probably be valuable for temperature & humidity, but electrical power
is probably best measured using `first-by-interval`.

Note that timestamps are in millisecond timestamps

+ Parameters
    + measurement (string) ... the measurement
    + device (string) ... the selected device
    + start (number) ... the timestamp (in seconds) of the beginning of the desired range
    + end (number) ... the timestamp (in seconds) of the end of the desired range
    + interval (number) ... the interval length (in seconds)

## Get the mean value of each interval [GET]

+ Response 200 (application/json)

    + Body

            [{t:1442551980533,r:225},
             {t:1442551985533,r:228},
             {t:1442551990533,r:false},
             {t:1442551995533,r:198}]

GRR! Because of InfluxDB's inconsistency, the whole thing may also just return

"no events"



# Device Subsampling by first event in range [/srv/first-by-interval{?measurement,device,start,end,interval}]

Return the first event in each interval. This will probably be the most
useful way to aggregate power readings.

+ Parameters
    + measurement (string) ... the measurement
    + device (string) ... the selected device
    + start (number) ... the timestamp (in seconds) of the beginning of the desired range
    + end (number) ... the timestamp (in seconds) of the end of the desired range
    + interval (number) ... the interval length (in seconds)

## Get the first event in each interval [GET]

For consistency, times are in milliseconds.  Right now, the time is
NOT the actual time of the first event, but simply the time that begins
the interval

+ Response 200 (application/json)

    + Body

            [{t:282379,r:229873},
             {t:282483,r:229874}]



# Device Event Range [/srv/events-in-range{?measurement,device,start,end}]

Fetch all events in the given range. More specifically, those with
timestamps `n` such that `start <= n < end`. Currently, the difference
between 'start' and 'end' can't be greater than 3600 seconds, to
limit the size of the response.

+ Parameters
    + measurement (string) ... the measurement
    + device (string) ... the selected device
    + start (number) ... the timestamp (in seconds) of the beginning of the desired range
    + end (number) ... the timestamp (in seconds) of the end of the desired range


## Get events in a range [GET]

NB: the responses have times in MILLISECONDS. Given the 53 bits of mantissa
in an IEEE 754 double, this should be plenty, allowing us to represent
dates up until the year 287,396.

+ Response 200 (application/json)

    + Body

            [{t:282379,r:229873},
             {t:282483,r:229874}]

# Count Device Events [/srv/count-events-in-range{?device,start,end}

+ Parameters
    + device (string) ... the id of the selected device
    + start (number) ... the timestamp of the beginning of the desired range
    + end (number) ... the timestamp of the end of the desired range

## Count events in a range [GET]

Returns a number representing the number of events in a time range.

+ Response 200 (application/json)

    + Body

            24739

# Subscribe to Events [/srv/subscribe]

Register a client with the server, to receive all events as they occur.
NB: There's no unsubscribe; I don't think it'll ever be necessary, and
the server will have to handle disappearing subscribers anyway.
[UNIMPLEMENTED]

## Subscribe [POST]

Some authentication here might be nice.  I'm going to leave it
out for now.

+ Request (application/json)

    + Body

            {"ip":"xxx.xxx.xxx.xxx"}

+ Response 200 (application/json)

    + Body

            true


# Group Client

# Notify [/totally/bogus]

Notification that an event has occurred.

As an aside, this model (that is, apiary) is totally broken... I can't refer to a model
from outside? There are some major issues here.

## Event [/client/notify]

Messages sent from the server to a subscribed client

+ Model (application/json)

    A JSON object representing a control or sensor event

    As a side note... this JSON schema mechanism is... weak.

    + Body

            {   "type": "controlorsensor",
                "device" : "thedevicename",
                "timestamp" : 472379717,
                "reading" : 2271938470
            }


### Notify [POST]

+ Request (application/json)
    [Event][]

+ Response 200 (application/json)

    + Body

            true

